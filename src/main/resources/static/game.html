<!DOCTYPE html>
<html>
<head>
    <title>è¿çº¿æŒ‘æˆ˜</title>
    <style>
        canvas {
            border: 2px solid #333;
            border-radius: 10px;
            background: #f0f0f0;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background: #fafafa;
        }
        #status {
            margin-top: 20px;
            font-size: 24px;
            color: #333;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="500"></canvas>
<div id="status">ç‚¹å‡»ç¬¬ä¸€ä¸ªåœ†å¼€å§‹è¿çº¿</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');

    // æ¸¸æˆé…ç½®
    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1'];
    const circleRadius = 25;
    const pointRadius = 5;

    // æ¸¸æˆçŠ¶æ€
    let circles = [];
    let connections = [];
    let selectedCircle = null;

    // ç”Ÿæˆåˆå§‹å¸ƒå±€
    function initializeGame() {
        circles = [];
        connections = [];

        // ç”Ÿæˆä¸‰å¯¹åœ†
        colors.forEach((color, index) => {
            const areaWidth = canvas.width / 3;
            const yBase = 100 + index * 120;

            // å·¦ä¾§åœ†
            circles.push({
                x: 50 + areaWidth * index,
                y: yBase + Math.random() * 50,
                color: color,
                connected: false
            });

            // å³ä¾§åœ†
            circles.push({
                x: canvas.width - 150 - areaWidth * index,
                y: yBase + Math.random() * 50,
                color: color,
                connected: false
            });
        });

        draw();
    }

    // ç»˜åˆ¶å…ƒç´ 
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ç»˜åˆ¶è¿æ¥çº¿
        connections.forEach(conn => {
            ctx.beginPath();
            ctx.moveTo(conn.start.x, conn.start.y);
            ctx.lineTo(conn.end.x, conn.end.y);
            ctx.strokeStyle = conn.color;
            ctx.lineWidth = 4;
            ctx.stroke();
        });

        // ç»˜åˆ¶åœ†
        circles.forEach(circle => {
            ctx.beginPath();
            ctx.arc(circle.x, circle.y, circleRadius, 0, Math.PI * 2);
            ctx.fillStyle = circle.color + '80'; // åŠé€æ˜
            ctx.fill();

            // ç»˜åˆ¶ä¸­å¿ƒç‚¹
            ctx.beginPath();
            ctx.arc(circle.x, circle.y, pointRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#333';
            ctx.fill();
        });

        // ç»˜åˆ¶é€‰ä¸­çŠ¶æ€
        if (selectedCircle) {
            ctx.beginPath();
            ctx.arc(selectedCircle.x, selectedCircle.y, circleRadius + 3, 0, Math.PI * 2);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    // çº¿æ®µäº¤å‰æ£€æµ‹
    function linesIntersect(a1, a2, b1, b2) {
        const ccw = (A,B,C) => (C.y-A.y)*(B.x-A.x) > (B.y-A.y)*(C.x-A.x);
        return ccw(a1,b1,b2) != ccw(a2,b1,b2) && ccw(a1,a2,b1) != ccw(a1,a2,b2);
    }

    // ç‚¹å‡»å¤„ç†
    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // æŸ¥æ‰¾ç‚¹å‡»çš„åœ†
        const clickedCircle = circles.find(circle =>
            Math.hypot(circle.x - mouseX, circle.y - mouseY) < circleRadius
        );

        if (!clickedCircle) return;

        if (selectedCircle) {
            // å°è¯•è¿æ¥
            if (selectedCircle.color === clickedCircle.color &&
                selectedCircle !== clickedCircle &&
                !clickedCircle.connected) {

                const newConnection = {
                    start: selectedCircle,
                    end: clickedCircle,
                    color: selectedCircle.color
                };

                // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–è¿çº¿äº¤å‰
                const hasCollision = connections.some(conn =>
                    linesIntersect(
                        newConnection.start, newConnection.end,
                        conn.start, conn.end
                    )
                );

                if (!hasCollision) {
                    connections.push(newConnection);
                    selectedCircle.connected = true;
                    clickedCircle.connected = true;
                    statusDiv.textContent = 'è¿æ¥æˆåŠŸï¼ç»§ç»­è¿æ¥å…¶ä»–é¢œè‰²';
                } else {
                    statusDiv.textContent = 'è¿çº¿äº¤å‰ï¼è¯·é‡æ–°é€‰æ‹©';
                }
            }
            selectedCircle = null;
        } else if (!clickedCircle.connected) {
            selectedCircle = clickedCircle;
            statusDiv.textContent = 'å·²é€‰æ‹©èµ·ç‚¹ï¼Œè¯·ç‚¹å‡»åŒè‰²ç»ˆç‚¹';
        }

        // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
        if (connections.length === colors.length) {
            statusDiv.textContent = 'ğŸ‰ æ­å–œï¼æ‰€æœ‰è¿æ¥å®Œæˆï¼';
        }

        draw();
    });

    // å¼€å§‹æ¸¸æˆ
    initializeGame();
</script>
</body>
</html>